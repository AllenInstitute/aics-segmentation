buildscript {
    ext {
        artifactoryContextUrl = 'https://artifactory.corp.alleninstitute.org/artifactory'
    }
    repositories {
        maven {
            url "${artifactoryContextUrl}/maven-virtual"
        }
        mavenCentral()
    }
}

plugins {
    // To see taskGraph for a task, on the command line type
    //         ./gradlew <task0> <task1> ... taskTree
    // This will NOT execute the tasks - it will only show the tree
    id "com.dorongold.task-tree" version "1.3.1"

    // Need this to specify location of .m2 settings.xml
    id "net.linguica.maven-settings" version "0.5"

    // Moving to RC version to avoid using JSch for SSH
    // This forces the move to Gradle 5.x
    id "org.ajoberstar.grgit" version "3.0.0-rc.2"
}

mavenSettings {
    userSettingsFileName = "/home/jenkins/.m2/settings.xml"
}

apply plugin: "idea"

///////////////////////////////////////////////////////////////////////////////////
// Config
// - Artifact name will be in settings.gradle parallel to this
///////////////////////////////////////////////////////////////////////////////////

class PyExtension {
    String venvRoot = "venv"

    // The virtual env with name X will be created in ./venv/X
    String venv = "x3"

    // The following will install the corresponding python version in the virtual env
    // This is the -p option to virtualenv
    // One of: python2 python2.7 python3 python3.6
    String venvPython = "python3"

    String binPath = "${venvRoot}/${venv}/bin"

    // The executables, with the path
    String python      = "${binPath}/python3"       // The python executable name
    String pip         = "${binPath}/pip3"          // Install requirements and update virtual env
    String flake8      = "${binPath}/flake8"        // Lint the code
    String twine       = "${binPath}/twine"         // Upload/publish to PyPi repos
    String bumpversion = "${binPath}/bumpversion"   // Manage versions
    String pytest      = "${binPath}/pytest"        // Used for testing
    String jupyter     = "${binPath}/jupyter"       // For Jupyter notebooks (if used)

    def env = makeEnv(venv)

    static Map<String,String> makeEnv(String name) {
        // This mimics the environment manipulations of the venv activate script
        def map = new HashMap<String,String>(System.getenv())
        map.put("VIRTUAL_ENV", new File("venv/${name}").getAbsolutePath())
        map.put("PATH", "venv/${name}/bin:${map.getOrDefault("PATH", "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin")}")
        map.remove("PYTHONHOME")
        return map
    }
}
project.extensions.create('py', PyExtension)
File versionFile   = file("${rootProject.name}/version.py")

wrapper {
    gradleVersion "5.0-milestone-1"
    distributionType "bin"
}

// Project version will be managed outside of gradle in accordance with PEP 440
// See "https://www.python.org/dev/peps/pep-0440/"
project.group = "org.alleninstitute.aics.pypi"

///////////////////////////////////////////////////////////////////////////////////

task cleanVenv {
    description "Remove the virtual environment root and all subdirectories"
    group "Generated file cleanup"

    doFirst {
        delete py.venv
    }
}

task clean {
    description "Clean all local build artifacts"
    group "Generated file cleanup"

    doFirst {
        delete "build"
        delete "dist"
        delete ".eggs"
        delete ".pytest_cache"
        delete "${project.name}.egg-info"
    }
}

task cleanAll {
    description "Clean all the virtual environment (subdirectory) as well as all local build artifacts"
    group "Generated file cleanup"

    dependsOn clean, cleanVenv
}

task createVirtualEnvEmpty {
    // This will assume virtualenv exists in the default project/system python
    description "Create the project virtual env in ${py.venvRoot}/${py.venv}"
    group "Python Virtual Environment Management"

    outputs.dirs(py.venvRoot)
    outputs.file("${py.binPath}/activate")

    doLast {
        exec {
            executable="virtualenv"
            args = ["-p", py.venvPython, "${py.venvRoot}/${py.venv}"]
        }
    }
}

task installDependencies {
    description "Install the development requirements in the virtual env"
    group "Python Virtual Environment Management"

    dependsOn createVirtualEnvEmpty
    inputs.files(py.pip)
    outputs.files(py.flake8, py.pytest)

    doLast {
        run(py.pip, ["install", "-e", ".[test_group]", "-e", ".[lint_group]"])
    }
}

task installJupyterDependencies  {
    description "Install the development requirements in the virtual env. Add jupyter based development tools. Optional"
    group "Python Virtual Environment Management"

    dependsOn installDependencies
    outputs.file(py.jupyter)

    doLast {
        run(py.pip, ["install", "-e", ".[jupyter_group]"])
    }
}

task installCIDependencies  {
    description "Install the development requirements in the virtual env, and CI tooling."
    group "Python Virtual Environment Management"

    dependsOn installDependencies
    outputs.files(py.bumpversion, py.twine)

    doLast {
        run(py.pip, ["install", "bumpversion", "twine"])
    }
}

task testPackage {
    description "Run tests"
    group "Python Build and Test Management"

    doLast {
        run(py.python, ["setup.py", "test"])
    }
}

task lint {
    description "Run the linter"
    group "Python Build and Test Management"

    dependsOn installDependencies

    doLast {
        run(py.flake8, ["--count", "--exit-zero", "${rootProject.name}"])
    }
}

task build {
    description "Build the wheel for local inspection. This will also create the virtual env and run tests."
    group "Python Build and Test Management"

    dependsOn lint, testPackage

    doLast {
        run(py.python, ["setup.py", "bdist_wheel"])
    }
}

task publishRelease {
    description "Publish the wheel to a PyPi repository (either internal release or global)"
    group "Python Publish"

    doLast {
        // Use the following for the repoAlias
        //    - release-local: internal releases
        //    - pypi: public releases
        uploadTo("pypi")
    }
}

task publishSnapshot {
    description "Publish the wheel to internal snapshot PyPi repository"
    group "Python Publish"

    doLast {
        uploadTo("snapshot-local")
    }
}

task bumpVersionRelease {
    description "Update version for release - X.Y.Z.devN -> X.Y.Z"
    group "Python Version Management"

    inputs.file(versionFile)
    outputs.file(versionFile)

    doLast {
        def version = getModuleVersion(versionFile)
        if (!version.contains(".dev")) {
            String message = "ERROR:\n" +
                    "The current version ${version} is not a snapshot (.devN) version. It cannot be bumped for release."
            throw new GradleException(message)
        }

        def bv = bumpTheVersion(["--tag",  "--list", "--allow-dirty", "release"])
        logger.info("Version changed from snapshot to relase version.")
        logger.info("\t${bv.oldVersion} -> ${bv.newVersion}")
    }
}

task bumpVersionDev {
    description "Update dev version within a snapshot - X.Y.Z.devN->X.Y.Z.devN+1"
    group "Python Version Management"

    inputs.file(versionFile)
    outputs.file(versionFile)

    doLast {
        def version = getModuleVersion(versionFile)
        if (!version.contains(".dev")) {
            String message = "ERROR:\n" +
                    "The current version (${version}) DOES NOT contain '.dev'. It cannot be bumped for next dev version."
            throw new GradleException(message)
        }

        def bv = bumpTheVersion(["--list", "--allow-dirty", "devbuild"])
        logger.info("Snapshot dev version bumped.")
        logger.info("\t${bv.oldVersion} -> ${bv.newVersion}")
    }
}

task bumpVersionPostRelease {
    description "Update version for next cycle - X.Y.Z -> X.Y.Z+1dev0"
    group "Python Version Management"

    inputs.file(versionFile)
    outputs.file(versionFile)

    doLast {
        // If you want to change the minor or major values for the next release, call this on the command line as
        // ./gradlew bumpVersionPostRelease -PbumpPartOverride=<value>
        // where the value is either minor or major

        def changePart = "patch"
        if (project.hasProperty('bumpPartOverride') && bumpPartOverride != changePart) {
            if (!["minor", "major"]) {
                throw new GradleException("ERROR:\nThe bumpPartOverride must be one of the following: minor, major")
            }
            logger.info("User is overriding the default bump part: ${changePart} -> ${bumpPartOverride}")
            changePart = bumpPartOverride
        }

        def bv = bumpTheVersion(["--list", "--allow-dirty", changePart])
        logger.info("Version bumped for next round of development.")
        logger.info("\t${bv.oldVersion} -> ${bv.newVersion}")
    }
}

task gitPushWithTag {
    description "Post-release/publish task to push the tag and the new version to git"
    group "Python Version Management"

    doLast {

    }
}

task gitPush {
    description "Post-snapshot/publish task to the new snapshot version to git"
    group "Python Version Management"

    doLast {

    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

def uploadTo(repoAlias) {
    exec {
        environment = py.env
        executable = py.twine
        args = ["upload", "-r", "${repoAlias}", "dist/*.whl"]
    }
}

def run(pyExec, pyArgs) {
    exec {
        environment = py.env
        executable = pyExec
        args = pyArgs
    }
}

class VersionInfo {
    String oldVersion = ""
    String newVersion = ""
}

def bumpTheVersion(bvArgs) {
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream()
    exec {
        environment = py.env
        executable = py.bumpversion
        args = bvArgs
        standardOutput = outputStream
    }
    def output = outputStream.toString()
    def info = new VersionInfo()
    info.oldVersion = (output =~ /current_version=(.+)/)[0][1]
    info.newVersion = (output =~ /new_version=(.+)/)[0][1]
    return info
}

static def getModuleVersion(versionFile) {
    def match = versionFile.filterLine { it =~ /^MODULE_VERSION/ } =~ /\"(.*)\"/
    return match[0][1]
}