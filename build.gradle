buildscript {
    ext {
        artifactoryContextUrl = 'https://artifactory.corp.alleninstitute.org/artifactory'
    }
    repositories {
        maven {
            url "${artifactoryContextUrl}/maven-virtual"
        }
        mavenCentral()
    }
}

plugins {
    // To see taskGraph for a task, on the command line type
    //         ./gradlew <task0> <task1> ... taskTree
    // This will NOT execute the tasks - it will only show the tree
    id "com.dorongold.task-tree" version "1.3.1"

    // Need this to specify location of .m2 settings.xml
    id "net.linguica.maven-settings" version "0.5"

    // Moving to RC version to avoid using JSch for SSH
    // This forces the move to Gradle 5.x
    id "org.ajoberstar.grgit" version "3.0.0-rc.2"
}

mavenSettings {
    userSettingsFileName = "/home/jenkins/.m2/settings.xml"
}

apply plugin: "idea"

///////////////////////////////////////////////////////////////////////////////////
// Config
// - Artifact name will be in settings.gradle parallel to this
///////////////////////////////////////////////////////////////////////////////////

class PyExtension {
    String venvRoot = "venv"

    // The virtual env with name X will be created in ./venv/X
    String venv = "x3"

    // The following will install the corresponding python version in the virtual env
    // This is the -p option to virtualenv
    // One of: python2 python2.7 python3 python3.6
    String venvPython = "python3"

    String binPath = "${venvRoot}/${venv}/bin"

    // The executables, with the path
    String python      = "${binPath}/python3"       // The python executable name
    String pip         = "${binPath}/pip3"          // Install requirements and update virtual env
    String flake8      = "${binPath}/flake8"        // Lint the code
    String twine       = "${binPath}/twine"         // Upload/publish to PyPi repos
    String bumpversion = "${binPath}/bumpversion"   // Manage versions
    String pytest      = "${binPath}/pytest"        // Used for testing
    String jupyter     = "${binPath}/jupyter"       // For Jupyter notebooks (if used)

    def env = makeEnv(venv)

    Map<String,String> makeEnv(String name) {
        // This mimics the environment manipulations of the venv activate script
        def map = new HashMap<String,String>(System.getenv())
        map.put("VIRTUAL_ENV", new File("venv/${name}").getAbsolutePath())
        map.put("PATH", "venv/${name}/bin:${map.getOrDefault("PATH", "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin")}")
        map.remove("PYTHONHOME")
        return map
    }
}

project.extensions.create('py', PyExtension)

wrapper {
    gradleVersion "5.0-milestone-1"
    distributionType "bin"
}

// Project version will be managed outside of gradle in accordance with PEP 440
// See "https://www.python.org/dev/peps/pep-0440/"
project.group = "org.alleninstitute.aics.pypi"

///////////////////////////////////////////////////////////////////////////////////

task cleanVenv {
    description "Remove the virtual environment root and all subdirectories"
    group "Generated file cleanup"

    doFirst {
        delete py.venv
    }
}

task clean {
    description "Clean all local build artifacts"
    group "Generated file cleanup"

    doFirst {
        delete "build"
        delete "dist"
        delete ".eggs"
        delete ".pytest_cache"
        delete "${project.name}.egg-info"
    }
}

task cleanAll {
    description "Clean all the virtual environment (subdirectory) as well as all local build artifacts"
    group "Generated file cleanup"

    dependsOn clean, cleanVenv
}

task createVirtualEnvEmpty {
    // This will assume virtualenv exists in the default project/system python
    description "Create the project virtual env in ${py.venvRoot}/${py.venv}"
    group "Python Virtual Environment Management"

    outputs.dirs(py.venvRoot)
    outputs.file("${py.binPath}/activate")

    doLast {
        exec {
            executable="virtualenv"
            args = ["-p", py.venvPython, "${py.venvRoot}/${py.venv}"]
        }
    }
}

task installDependencies {
    description "Install the development requirements in the virtual env"
    group "Python Virtual Environment Management"

    dependsOn createVirtualEnvEmpty
    inputs.files(py.pip)
    outputs.files(py.flake8, py.pytest)

    doLast {
        run(py.pip, ["install", "-e", ".[test_group]", "-e", ".[lint_group]"])
    }
}

task installJupyterDependencies  {
    description "Install the development requirements in the virtual env. Add jupyter based development tools. Optional"
    group "Python Virtual Environment Management"

    dependsOn installDependencies
    outputs.file(py.jupyter)

    doLast {
        run(py.pip, ["install", "-e", ".[jupyter_group]"])
    }
}

task installCIDependencies  {
    description "Install the development requirements in the virtual env, and CI tooling."
    group "Python Virtual Environment Management"

    dependsOn installDependencies
    outputs.files(py.bumpversion, py.twine)

    doLast {
        run(py.pip, ["install", "bumpversion", "twine"])
    }
}

task testPackage {
    description "Run tests"
    group "Python Build and Test Management"

    doLast {
        run(py.python, ["setup.py", "test"])
    }
}

task lint {
    description "Run the linter"
    group "Python Build and Test Management"

    dependsOn installDependencies

    doLast {
        run(py.flake8, ["--count", "--exit-zero", "${rootProject.name}"])
    }
}

task build {
    description "Build the wheel for local inspection. This will also create the virtual env and run tests."
    group "Python Build and Test Management"

    dependsOn lint, testPackage

    doLast {
        run(py.python, ["setup.py", "bdist_wheel"])
    }
}

task publishRelease {
    description "Publish the wheel to a PyPi repository (either internal release or global)"
    group "Python Publish"

    doLast {
        // Use the following for the repoAlias
        //    - release-local: internal releases
        //    - pypi: public releases
        uploadTo("pypi")
    }
}

task publishSnapshot {
    description "Publish the wheel to internal snapshot PyPi repository"
    group "Python Publish"

    doLast {
        uploadTo("snapshot-local")
    }
}

task bumpReleaseVersion {
    description "Update version for release - X.Y.Z.devN -> X.Y.Z"
    group "Python Version Management"
    doLast {
        ByteArrayOutputStream ostream = new ByteArrayOutputStream()
        exec {
            environment py.env
            executable = py.bumpversion
            args = ["--tag",  "--list", "--allow-dirty", "release"]
            standardOutput = ostream
        }
        showVersions(ostream)
    }
}

task bumpSnapshotVersion {
    description "Update version for next cycle - X.Y.Z -> X.Y.Z+1dev0, or next snapshot X.Y.Z.devN->X.Y.Z.devN+1"
    group "Python Version Management"

    def changePart = "patch"

     // sh "${PYTHON} ${VENV_BIN}/bumpversion --list ${bump_part} | grep \"current_version\\|new_version\" > bumpversion_post.out"
    doLast {
        ByteArrayOutputStream ostream = new ByteArrayOutputStream()
        exec {
            environment py.env
            executable = py.bumpversion
            args = ["--list", "--allow-dirty", changePart]
            standardOutput = ostream
        }
        showVersions(ostream)
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

def showVersions(ostream) {
    def output = ostream.toString()
    println "OUT = ${output}"
    def prev_version = output =~ /current_version=(.+)/
    def new_version = output =~ /new_version=(.+)/
    println "Previous version = ${prev_version[0][1]}"
    println "New version = ${new_version[0][1]}"
}

def uploadTo(repoAlias) {
    exec {
        environment py.env
        executable py.twine
        args "upload -r ${repoAlias} dist/*.whl"
    }
}

def run(pyExec, pyArgs) {
    exec {
        environment py.env
        executable = pyExec
        args = pyArgs
    }
}