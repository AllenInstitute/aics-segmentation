buildscript {
    ext {
        artifactoryContextUrl = 'https://artifactory.corp.alleninstitute.org/artifactory'
    }
    repositories {
        maven {
            url "${artifactoryContextUrl}/maven-virtual"
        }
        mavenCentral()
    }
}

plugins {
    // To see taskGraph for a task, on the command line type
    //         ./gradlew <task0> <task1> ... taskTree
    // This will NOT execute the tasks - it will only show the tree
    id "com.dorongold.task-tree" version "1.3.1"

    // Need this to specify location of .m2 settings.xml
    id "net.linguica.maven-settings" version "0.5"

    // Moving to RC version to avoid using JSch for SSH
    // This forces the move to Gradle 5.x
    id "org.ajoberstar.grgit" version "3.0.0-rc.2"
}

mavenSettings {
    userSettingsFileName = "/home/jenkins/.m2/settings.xml"
}

apply plugin: "idea"

///////////////////////////////////////////////////////////////////////////////////
// Config
// - Artifact name will be in settings.gradle parallel to this
///////////////////////////////////////////////////////////////////////////////////

class PyExtension {
    String venvRoot = "venv"

    // The virtual env with name X will be created in ./venv/X
    String venv = "x3"

    // The following will install the corresponding python version in the virtual env
    // This is the -p option to virtualenv
    // One of: python2 python2.7 python3 python3.6
    String venvPython = "python3"

    String binPath = "${venvRoot}/${venv}/bin"

    // The executables, with the path
    String python      = "${binPath}/python3"       // The python executable name
    String pip         = "${binPath}/pip3"          // Install requirements and update virtual env
    
    String flake8      = "${binPath}/flake8"        // Lint the code
    String pytest      = "${binPath}/pytest"        // Used for testing
    
    String twine       = "${binPath}/twine"         // Upload/publish to PyPi repos
    String bumpversion = "${binPath}/bumpversion"   // Manage versions

    def env = makeEnv(venv)

    static Map<String,String> makeEnv(String name) {
        // This mimics the environment manipulations of the venv activate script
        def map = new HashMap<String,String>(System.getenv())
        map.put("VIRTUAL_ENV", new File("venv/${name}").getAbsolutePath())
        map.put("PATH", "venv/${name}/bin:${map.getOrDefault("PATH", "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin")}")
        map.remove("PYTHONHOME")
        return map
    }
}

project.extensions.create('py', PyExtension)
File pythonVersionFile = file("${rootProject.name}/version.py")
File bumpVersionCfgFile = file("${projectDir}/.bumpversion.cfg")

wrapper {
    gradleVersion "5.0-milestone-1"
    distributionType "bin"
}

// Project version will be managed outside of gradle in accordance with PEP 440
// See "https://www.python.org/dev/peps/pep-0440/"
project.group = "org.alleninstitute.aics.pypi"

///////////////////////////////////////////////////////////////////////////////////

task cleanVenv {
    description "Remove the virtual environment root and all subdirectories"
    group "Generated file cleanup"

    doFirst {
        delete "${py.venvRoot}"
    }
}

task clean {
    description "Clean all local build artifacts"
    group "Generated file cleanup"

    doFirst {
        delete "build"
        delete "dist"
        delete ".eggs"
        delete ".pytest_cache"
        delete "${project.name}.egg-info"
    }
}

task cleanAll {
    description "Clean all the virtual environment (subdirectory) as well as all local build artifacts"
    group "Generated file cleanup"

    dependsOn clean, cleanVenv
}

task createVirtualEnvEmpty {
    // This will assume virtualenv exists in the default project/system python
    description "Create the project virtual env in ${py.venvRoot}/${py.venv}"
    group "Python Virtual Environment Management"

    outputs.dirs("${py.venvRoot}")
    outputs.file("${py.binPath}/activate")

    doLast {
        exec {
            executable="virtualenv"
            args = ["-p", py.venvPython, "${py.venvRoot}/${py.venv}"]
        }
    }
}

task installDependencies {
    description "Install the development requirements in the virtual env"
    group "Python Virtual Environment Management"

    dependsOn createVirtualEnvEmpty
    inputs.files(py.pip)
    outputs.files(py.flake8, py.pytest)

    doLast {
        run(py.pip, ["install", "-e", ".[test_group]", "-e", ".[lint_group]"])
    }
}

task installInteractiveDevDependencies  {
    description "Install the interactive development requirements in the virtual env, e.g. Jupyter."
    group "Python Virtual Environment Management"

    dependsOn installDependencies

    doLast {
        run(py.pip, ["install", "-e", ".[interactive_dev_group]"])
    }
}

task installCIDependencies  {
    description "Install the development requirements in the virtual env, and CI tooling."
    group "Python Virtual Environment Management"

    dependsOn installDependencies
    outputs.files(py.bumpversion, py.twine)

    doLast {
        run(py.pip, ["install", "bumpversion", "twine"])
    }
}

task testPackage {
    description "Run tests"
    group "Python Build and Test Management"

    doLast {
        run(py.python, ["setup.py", "test"])
    }
}

task lint {
    description "Run the linter"
    group "Python Build and Test Management"

    dependsOn installDependencies

    doLast {
        run(py.flake8, ["--count", "--exit-zero", "${rootProject.name}"])
    }
}

task build {
    description "Build the wheel for local inspection. This will also create the virtual env and run tests."
    group "Python Build and Test Management"

    dependsOn lint, testPackage

    doLast {
        run(py.python, ["setup.py", "bdist_wheel"])
    }
}

task publishRelease {
    description "Publish the wheel to a PyPi repository (either internal release or global)"
    group "Python Publish"

    doLast {
        // Use the following for the repoAlias
        //    - release-local: internal releases
        //    - pypi: public releases
        uploadTo("pypi")
    }
}

task publishSnapshot {
    description "Publish the wheel to internal snapshot PyPi repository"
    group "Python Publish"

    doLast {
        uploadTo("snapshot-local")
    }
}

task bumpVersionRelease {
    description "Update version for release - X.Y.Z.devN -> X.Y.Z"
    group "Python Version Management"

    inputs.file(pythonVersionFile)
    outputs.file(pythonVersionFile)

    doLast {
        def version = getModuleVersion(pythonVersionFile)
        if (!version.contains(".dev")) {
            String message = "ERROR:\n" +
                    "The current version ${version} is not a snapshot (.devN) version. It cannot be bumped for release."
            throw new GradleException(message)
        }

        bumpTheVersion(["--list", "--allow-dirty", "release"], "Version changed from snapshot to relase version.")
    }
}

task bumpVersionDev {
    description "Update dev version within a snapshot - X.Y.Z.devN->X.Y.Z.devN+1"
    group "Python Version Management"

    inputs.file(pythonVersionFile)
    outputs.file(pythonVersionFile)

    doLast {
        def version = getModuleVersion(pythonVersionFile)
        if (!version.contains(".dev")) {
            String message = "ERROR:\n" +
                    "The current version (${version}) DOES NOT contain '.dev'. It cannot be bumped for next dev version."
            throw new GradleException(message)
        }

        bumpTheVersion(["--list", "--allow-dirty", "devbuild"], "Snapshot dev version bumped.")
    }
}

task bumpVersionPostRelease {
    description "Update version for next cycle - X.Y.Z -> X.Y.Z+1dev0"
    group "Python Version Management"

    inputs.file(pythonVersionFile)
    outputs.file(pythonVersionFile)

    doLast {
        // If you want to change the minor or major values for the next release, call this on the command line as
        // ./gradlew bumpVersionPostRelease -PbumpPartOverride=<value>
        // where the value is either minor or major

        def changePart = "patch"
        if (project.hasProperty('bumpPartOverride') && bumpPartOverride != changePart) {
            if (!["minor", "major"]) {
                throw new GradleException("ERROR:\nThe bumpPartOverride must be one of the following: minor, major")
            }
            logger.info("User is overriding the default bump part: ${changePart} -> ${bumpPartOverride}")
            changePart = bumpPartOverride
        }

        bumpTheVersion(["--list", "--allow-dirty", changePart], "Version bumped for next round of development.")
    }
}

task gitTagCommitPush {
    description "Post-release/publish task to push the tag and the new version to git"
    group "Python Version Management"

    inputs.file(pythonVersionFile)
    inputs.file(bumpVersionCfgFile)

    doLast {
        def vcs = grgit.open()
        def moduleVersion = getModuleVersion(pythonVersionFile)
        def branchName = vcs.branch.current().getName()
        def commit = commitVersionChanges([pythonVersionFile, bumpVersionCfgFile], "Release version ${moduleVersion}")
        vcs.tag.add(name: "${moduleVersion}", message: "Release version ${moduleVersion}", pointsTo: commit, annotate: true)
        // Now push the committed files and the tag!

        vcs.pull()
        vcs.push(remote: "origin", refsOrSpecs: ["refs/tags/${moduleVersion}", "refs/heads/${branchName}"])
    }
}

task gitCommitPush {
    description "Post-snapshot/publish task to the new snapshot version to git"
    group "Python Version Management"

    inputs.file(pythonVersionFile)
    inputs.file(bumpVersionCfgFile)

    doLast {
        def vcs = grgit.open()
        def moduleVersion = getModuleVersion(pythonVersionFile)
        commitVersionChanges([pythonVersionFile, bumpVersionCfgFile], "Next dev version: ${moduleVersion}")

        vcs.pull()
        vcs.push(remote: "origin")
    }
}

task debugInfo {
    inputs.file(pythonVersionFile)

    doLast {
        def moduleVersion = getModuleVersion(pythonVersionFile)
        println("Current module version: ${moduleVersion}")

        def vcs = grgit.open()
        def branch = vcs.branch.current().getName()
        println("Current branch: ${branch}")
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

def uploadTo(repoAlias) {
    def localCerts = ["--cert", "/etc/ssl/certs/aics-ca.pem"]
    def uploadArgs = ["upload", "-r", "${repoAlias}"] + (repoAlias.contains("-local") ? localCerts : []) + ["dist/*.whl"]
    println("Upload Args: ${uploadArgs}")
    exec {
        environment = py.env
        executable = py.twine
        args = uploadArgs
    }
}

def run(pyExec, pyArgs) {
    exec {
        environment = py.env
        executable = pyExec
        args = pyArgs
    }
}

class VersionInfo {
    String oldVersion = ""
    String newVersion = ""
}

def bumpTheVersion(bvArgs, logMessage) {
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream()
    exec {
        environment = py.env
        executable = py.bumpversion
        args = bvArgs
        standardOutput = outputStream
    }
    def output = outputStream.toString()
    def info = new VersionInfo()
    info.oldVersion = (output =~ /current_version=(.+)/)[0][1]
    info.newVersion = (output =~ /new_version=(.+)/)[0][1]

    logger.info(logMessage)
    logger.info("\t${bv.oldVersion} -> ${bv.newVersion}")

    return info
}

static def getModuleVersion(versionFile) {
    def versionLineFilter = versionFile.filterLine { it =~ /\s*MODULE_VERSION\s*=\s*"\d+\.\d+\.\d+(\.dev\d+)?"/ }
    def versionLine = versionLineFilter.toString()
    if (versionLine.isEmpty()) {
        throw new GradleException("ERROR:\n" +
                "Expected a line of the following form in version file ${versionFile}\n" +
                "MODULE_VERSION = \"X.Y.Z[.devN]\"")
    }
    def match = versionLine =~ /"(.*)"/
    return match[0][1]
}

def commitVersionChanges(filesToCommit, commitMessage) {
    def vcs = grgit.open()
    def modified = vcs.status().unstaged['modified']

    filesToCommit.forEach {
        // Ensure inputs are relative project directory to match modified
        def path = it.toString().replaceAll("${projectDir}/", "")
        if (modified.contains(path)) {
            vcs.add(patterns: [path])
        }
    }
    logger.info("Files staged for commit: ${vcs.status().staged['modified']}")

    def commit = vcs.commit(message: commitMessage)
    logger.info("Commit: ${commit.abbreviatedId}")
    logger.info("Commit: ${commit.shortMessage}")
    return commit
}